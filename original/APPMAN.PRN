






	 　　80x86 アセンブラ構造化支援簡易プリプロセッサ APP.EXE

            Assembler tiny Pre Prosessor  ＡＰＰ   (C) Ｍｉｏ 1992







◎イントロダクション◎

　　ＡＰＰはＡＰＰの文法に基づいて記述されたＡＰＰ文、およびニーモニックを、
　アセンブラに掛けられるソースに変換するという形でプログラミングを支援します。
　オブジェクトの作成には、ＡＰＰが生成する８０ｘ８６ニーモニックの解釈が可能な
　アセンブラが必要です。

　　予約語の名前などは（Ｃ＋Ｐａｓｃａｌ＋ＢＡＳＩＣ）／３という感じになって
　いますので、高級言語プログラミングの経験があれば、　なんとなく似た雰囲気で
　プログラムを記述することができますが、プリプロセッサの名前の通り、コンパイラ
　では有りませんので、文脈の解釈等はほとんど行わず、１対１の変換が基本となって
　います。したがって、文法チェックはほとんどアセンブラに任せる形になっています。
　またＡＰＰはフログラム構造しかサポートしませんので、実際の演算を記述するため
　には８０ｘ８６インストラクションの知識が必要となります。

　現在の所、次の処理系のプリプロセッサとして使用可能なことが確認されています。

　　　　２５００Ａ．Ｄ．（Ｘ８０１８６）
	ＭＡＳＭ			（制限あり）
　　　　ＴＡＳＭ			（制限あり）

　また、TURBO Pascal Ver6.0 のインラインアセンブラ文の規則に対応する機能も
　組み込まれています。
.p


　ＡＰＰがサポートするのは以下の機能です。

　１．構造化制御文

　　構造化制御文とは、アセンブラプログラムのほとんどに使用されるプログラム
　の流れの形を、できるだけ見易い形（書きやすい形）で表現できるように、
　ニーモニックをよりその形に近づけて拡張したものです。

　拡張されたニーモニックは通常のニーモニック、擬似命令と区別するため、
　すべて英小文字で記述され、さらにその先頭には _ （アンダースコア）を付けて
　表されます。

　構造化制御文には３つの種類があります。

	ａ．ｉｆ文　（条件分岐）

	ｂ．ｓｗｉｔｃｈ文（多方向分岐）

	ｃ．ループ文


　２．高級言語風サブルーチン

　　サブルーチンを呼び出す場合、通常サブルーチンに対して何らかのデータを渡し、
　またそのデータを加工して何らかのデータを受け取るということを行う場合が多く
　あります。

　　高級言語では、サブルーチンにデータ（引き数）を渡す機構、サブルーチンの中
　だけで使う変数を管理する機構（ローカル変数）、　またサブルーチン内で生じた
　結果、データ等を呼び出し側に返す機構（関数形式、戻り値）が用意され、　上で
　述べた操作を比較的楽に行えるようになっています。

　ＡＰＰではこれに習い、アセンブラの柔軟性を損なわないよう、

　　１．出来るだけ特定のレジスタに依存しない。

　　２．高級言語コンパイラが出力するコードと同等か、より効率のよいコードを
　　　　生成する。

　上記に重点をおいて、以下の点を実現しました。

　　レジスタの保存の半自動化。
　　レジスタ引き数の受け渡し命令の生成。
　　再帰型関数の実現可能な擬似関数。

　ＡＰＰのサブルーチン形式としては、

	ａ．ｐｒｏｃｅｄｕｒｅ　形式　（通常のサブルーチン）

	ｂ．ｆｕｎｃｔｉｏｎ　　形式　（擬似関数形式のサブルーチン）

　の２種があり、それぞれ特徴を持っています。
.p


◎マニュアル／説明◎

１．構造化制御文

　ａ．ｉｆ文

　　通常のニーモニックでは、「もしａｘ＝１５ならば、処理ＯＯをおこなう」
　というような場合、

	CMP	AX,15
	JNE	LABEL

	処理ＯＯ

LABEL:

　の様に書きます。こういう処理はプログラム中無数にあらわれ、その度に
　　ＣＭＰ、Ｊｃｃ（条件ジャンプ）、飛び先ラベル：
　の３つを意識して書かねばなりません。

　この時の条件ジャンプは「もし〜ならば」の条件の反対のものを考えねばならず、
　ほとんどの場合意味の無いラベルを意識して作成することになります。

　また、「もしａｘ＝１５ならば処理ＯＯ、そうでなければ処理ｘｘ」などという
　場合には、

	CMP	AX,15
	JNE	LABEL1

	処理ＯＯ

	JMP	LABEL2
LABEL1:

	処理ｘｘ

LABEL2:

　と書かねばならず、ラベルを更に余計に考えねばなりません。
　ラベルの衝突を避けることも考えねばならず、上のような処理を無意識に書ける
　ようになるには習熟を必要とします。
　なれた人でも条件を逆に書いてしまうなどのミスを犯してしまうこともあります。

　ｉｆ文を使用するとラベルの作成と条件ジャンプの作成を半自動で行えます。

　始めの例をｉｆを使用して書き直すと、

	_if	AX == 15

		処理ＯＯ

	_endif

　となり、ラベルを意識して作る必要がなくなります。　また＝という表現を使う
　ことで、より自然に書きやすく、見易いソースとなります。

　また後の例も、

	_if	AX == 15

		処理ＯＯ

	_else

		処理ＸＸ

	_endif

　と書けます。

　ｉｆ文の条件は　変数／関数／レジスタ　比較演算子　変数／レジスタ／即値
　の順序で記述されます（ＣＭＰの２つの引き数に展開される）。

　比較演算子としては、= 「等しい」、<> 「異なる」、<= 「以下」、>= 「以上」
　< 「より小さい」、> 「より大きい」、& 「ビットテスト」、~& 「ビットテスト」
　の８つが使用できます。 （「等しい」は == 、「異なる」は != も可）
　& は２つめの引き数と TEST した結果０でないとき成立、~& は０のとき成立です。
　また、フラグによる判断も可能です（後述）


　多少制限があるものの、条件を複数ならべて書くこともできます。
  「ａｘが１０から２０の間なら処理ＯＯをおこなう」というのは、

　_if	AX>=10 && AX<=20	; && は 「かつ」を表す。

	処理ＯＯ

　_endif

　また、「ａｘが１０より小さいか、１００より大きいとき処理ｘｘをおこなう」は

　_if	AX<=10 || AX>=100	; || は　「もしくは」を表す。

	処理ＸＸ

　_endif

　と書けます。

　ただし、一つのｉｆ文中に && と || を混在させることはできません。
　混在させなければ、|| , && をいくつ使用してもかまいません。

　なお、|| , && を使用した場合の条件式の展開は、一番最後に書かれているものから
　行われます。

　（_if	(A) || (B) || (C)  は、　(C)=>(B)=>(A) の順で展開される）

　このような条件式は、ＡＰＰではｉｆ文以外にも、ループ文、ｓｗｉｔｃｈ文で
　使用されますが、その場合にもｉｆ文に準じた表記が可能です。

　他の文では条件式の説明はしませんので、ｉｆ文の条件式の説明を参照して下さい。
.p

　《ＡＰＰの条件式に関する注意事項》

　　ＡＰＰにおける条件式は、あくまでも CMP 命令の両辺を決定するものであり、
　特にＡＰＰが解釈、変換可能な特殊な表現を除いてそのままニーモニックとなって
　アセンブラソースに出力されます。

　したがって、ＣＭＰ命令の両辺の型の不一致、記述不能な表現に対してもＡＰＰが
　警告を出さない事がありますが、ＡＰＰでエラーにならない場合でも、アセンブラ
　の段階でエラーとなることがあります。


　《特殊な条件式−フラグによる判断》

　　通常プログラムの中で発生する条件はレジスタの比較等で発生する場合が多いの
　ですが、フラグなどの状態によって条件分岐を行いたいための場合に、ＡＰＰの
　条件式として、以下の表現を許しています。

	_if C

		（キャリー＝１　時の処理）

	_else

		（キャリー＝０　時の処理）

	_endif

　_if 、C （キャリー）以外でももちろん可能です。

　ただし、このような条件式部分に直接フラグ名を書く表現は、単独で使用する
　（|| , && を使わない） 場合にのみ保証されます。

　これは、組み合わせる条件で通常の式を書いた場合、CMP 命令が生成されてしまう
　ため、それによってフラグが破壊される可能性があるためです。
　どうしても使用しなければいけない場合には、生成されるコードに十分注意する
　必要があります。
.p

　ｂ．ｓｗｉｔｃｈ　文

　　ｓｗｉｔｃｈ文は、条件によって多数の処理を選択する場合に使います。

　例えば、「ａｘが１のときは処理ＯＯ、ａｘが２のときは処理ＸＸ、それ以外の時
　処理−−」というのは、

	_switch
	_case	ax = 1

		処理ＯＯ

	_case	ax = 2

		処理ＸＸ

	_default

		処理−−

	_ends

　と書けます。

　ｓｗｉｔｃｈ文は　ｓｗｉｔｃｈーｅｎｄｓ間に記述され、
　ｃａｓｅ（条件式）のあとに、条件成立時の処理を書きます。

　（条件式）はｉｆ文と同様に記述できます。

　ｄｅｆａｕｌｔ文は、ｅｎｄｓの手前に書き、ｃａｓｅ文のすべての条件が
　成立しなかったときに実行する処理を書きます。
　相当する処理が無い場合は、ｄｅｆａｕｌｔ文はなくてもかまいません。

　ｃａｓｅはｓｗｉｔｃｈーｅｎｄｓ間にいくつでも（ＡＰＰのメモリの限界まで）
　書くことができますが、ｓｗｉｔｃｈーｅｎｄｓ間に別のｓｗｉｔｃｈブロックを
　書くことはできません（ネスト不可）。
.p

　ｃ．ループ文

　　ループ文はプログラム中で頻繁に登場するくり返し処理を簡単に、見易く記述する
　ためのものです。

　　一般的なループ文として、次の３種類があります。

　　　ア．　ｗｈｉｌｅーｗｅｎｄ　文

　　　イ．　ｒｅｐｅａｔーｕｎｔｉｌ　文

　　　ウ．　ｆｏｒーｎｅｘｔ　文

　　特殊なループ文として１種類

　　　エ．　ｌｏｏｐｃｘーｅｎｄｌ　文

　　計４種類が存在し、様々なくり返し処理に対応できます。


　ア．ｗｈｉｌｅーｗｅｎｄ　文

　　これは、ある条件が成立している間、くり返し処理を行う場合に使用します。

　例えば、「ａｘが１００より小さい間、処理ＯＯをくり返し行う」というのは、

	_while	ax < 100

		処理ＯＯ

	_wend

　と書けます。

　条件部分が始めから成立しない場合には、処理は一度も実行されません。
　なお条件部分にはｉｆ文と同様の記述が可能です。
　条件式を省略することはできません。


　イ．ｒｅｐｅａｔーｕｎｔｉｌ　文

　　これは、ある条件が成立するまで、くり返し処理を行う場合に使用します。

　例えば、「入力ポートを監視して、最下位ビットが立つまで待つ」というのは、

	_repeat
		IN	AX,DX
	_until	AX & 01H

　と書けます。

　どのような場合でも、必ず１回はループ内が実行されます。
　条件部分にはｉｆ文と同様の記述が可能です。
　条件式を省略することはできません。
.p

　ウ．ｆｏｒーｎｅｘｔ　文

　　これは、何らかのカウンタを増加／減少させながら、カウンタが一定の値になる
　まで処理をくり返し行う場合に使用します。

　例えば、「１から１０までの和をｄｘレジスタに求める」というのは、

	XOR	DX,DX
	_for	AX = 1 , AX <= 10 , AX++
		ADD	DX,AX
	_next

　と書けます。

　ｆｏｒ文の書式は、
  
	_for （初期値）,（条件）,（レジスタ／変数名）++ or --　で、


　（初期値）の部分には、（カウンタ名）＝（初期値）という書式で、カウンタと
　初期値を記述します。

　（条件）の部分には、ｉｆ文と同じ形式で、ループを繰り返す条件を書きます。
　（条件）が成立している間、ｆｏｒーｎｅｘｔ間の実行が繰り返されます。

　最後の部分には、（レジスタ／変数名）++ or -- という形式で、
　カウンタ名と、それに続けて、ループを一回繰り返すごとにカウンタを増加する
　場合には ++ を、減少する場合には -- を記述します。

　（初期値）の部分で使用したカウンタ名と、最後の部分で使用するカウンタ名は
　必ずしも一致させる必要はありません。

　（条件）が始めから成立しない場合には、ループ内は一度も実行されません。

　ｆｏｒ文とまったく同じ動作をｗｈｉｌｅ文を用いて記述すると、

	MOV	（カウンタ名）,（初期値）
	_while	（条件）

		ループ内処理

		INC or DEC （カウンタ）
	_wend

　となります。

　《ｆｏｒ文におけるパラメータの省略 (Release 1.31)》

　　Rel 1.31 では、ｆｏｒ文のパラメータを省略出来るようになりました。
　（初期値）、（条件）、（カウンタ増／減）の任意のパラメータを省略可能です。　
　ただし、区切り記号の（，）は省略できません。

　すべてのパラメータを省略した場合には、無限ループを生成します。
.p


　《ｆｏｒ文のインクリメント／デクリメントの増分指定 (Ver 1.40 以降)》

    Ver 1.40 以降のバージョンでは、レジスタ／変数の増（減）分として、１以外の数
　を指定可能になりました。
　＋＝、−＝　記号を用いる事で、２以上の増減分を記述できます。

　（例）
	_for	AX=0,AX < 100,AX += 5
		; ＡＸが５ずつ増えるループ
	_next

　なお、展開後のコードは以下の通りです。

        _for    AX=0,AX < 100,AX += 5
        ;        _for    AX=0,AX < 100,AX += 5
        MOV     AX,0
        JMP     $FORBG_1
$BEGIN_1:
                ; ＡＸが５ずつ増えるループ
        _next
        ;        _next
        ADD     AX,5
$FORBG_1:
        CMP     AX,100
        JB      $BEGIN_1

.p

　エ．ｌｏｏｐｃｘーｅｎｄｌ　文

　　これは８０ｘ８６に特有のＣＸレジスタを用いたくり返し命令を生成する文で、
　ＣＸをある値から１まで減らしながらくり返し処理を行うものです。

　「１０回、処理ＯＯをくりかえして行う」というのは、

	_loopcx	10

		処理ＯＯ

	_endl

　と書きます。

　ｌｏｏｐｃｘ　文に与えるパラメータは１つだけで、ＣＸの初期値です。
　パラメータとして、定数又はレジスタが使用できます。
　また、初期値を省略することもできます（省略した場合その時点のＣＸの値が
　初期値となる）。

　ｌｏｏｐｃｘ　ループをネストした場合には、最外ループを除いて、初期値の代入
　の手前の位置に PUSH CX 、ループの後に POP CX が生成されます。
　（多重ループからの脱出に関しては　_continue , _exit の注意を参照の事）

　初期値が数値定数（即値）以外の場合には、JCXZ ステートメントがループの手前に
　生成され、初期値が０のときに６５５３６回実行されるのを防ぎます。
.p

　＜ループ内のみで使用できる文＞

　　４種類のいずれかのループ中でのみ使用できる命令として、
　　ｅｘｉｔ文、ｃｏｎｔｉｎｕｅ文があります。


　１．ｅｘｉｔ　文

　　ループから脱出する場合に使用します。
　　多重ループの時には、一番内側のループから脱出します。

　　（例）
	_repeat
		_while	ax < 100
			_if	bx = 100
				_exit
			_endif
				.
				.
				.
		_wend
		（ここへの脱出となる）
	_until	bx < 100



　２．ｃｏｎｔｉｎｕｅ　文

　　ループ内の処理の途中から、条件判断部分に移りたい時に使用します。
　　ｆｏｒ文中で使われたときには、カウンタの増加／減少処理のあと、
　　条件判断に移ります。

　　（例）
	_while	ax = 0 <--------+
		.		|　（線の通りにジャンプ）
		.		|
		_continue ------+
		.
		.
	_wend


	_repeat
		.
		.
		_continue ------+
		.		|
		.		|
	_until	cx = 0 <--------+
.p

　《ｅｘｉｔ、ｃｏｎｔｉｎｕｅの脱出レベル指定について (Release 1.30)》

　　Rel 1.30 以降のバージョンでは、ｅｘｉｔ、ｃｏｎｔｉｎｕｅ文にたいして
　脱出レベルパラメータを与えることで、いくつものループから一度に脱出できる
　ようになりました。

　　ただし、多重ｌｏｏｐｃｘループからの１レベル以上の脱出はサポートされ
　ません。これは、多重ｌｏｏｐｃｘループの実現のためにＣＸレジスタをＰＵＳＨ
　する命令が最外ループを除くすべてのループに付加され、脱出ジャンプ時にそれを
　ＰＯＰする機能を現在のバージョンのＡＰＰが備えていないためです。

　書式は、
	_exit		（脱出レベル）
	_continue	（脱出レベル）

　で、パラメータなしの場合は今まで通りの動作となります。
　脱出レベル＝０のとき、最内ループからの脱出（省略時）です。
　１以上の時、余計にその数字のぶんだけ脱出します。

　（例）
	_for a=1,a<=10,a++
		_for b=1,b<=10,b++
			_for c=1,c<=10,c++
				_exit	1	; (A)
				_exit	0	; (B)
				_exit		; (C)
				_exit	2	; (D)
			_next
			(B),(C) はここへの脱出
			_exit	1		; (E)
		_next
		(A) はここへの脱出
	_next
	(D),(E) はここへの脱出

　脱出レベルパラメータはＡＰＰに対する指示であり、即値１０進数以外を与えては
　なりません（レジスタ、シンボル、１６進数は不可）
.p


２．高級言語風サブルーチン


　ａ．ｐｒｏｃｅｄｕｒｅ形式

　　ｐｒｏｃｅｄｕｒｅ形式はアセンブラの通常のサブルーチンの形となる

LABEL:
	サブルーチン処理

	RET

　に対応する定義文 ｐｒｏｃｅｄｕｒｅーｅｎｄｐ と、呼び出し部分 CALL に
　対応する呼び出し文 ｐｒｏｃ とからなります。

　ＡＰＰの場合、定義文を書いた位置にサブルーチンのコードが生成されます。
　また、原則として定義文より前に呼び出し文を書くことはできません（２パス変換
　又はヘッダ形式を使用すれば可能）。

　ｐｒｏｃｅｄｕｒｅ形式の場合、定義文 ｐｒｏｃｅｄｕｒｅ が LABEL: に対応し、
　ｅｎｄｐ が RET に相当します。
　ｅｎｄｐｉと書くと、IRET が生成されます（Ver 1.40 以降）。

　定義文 ｐｒｏｃｅｄｕｒｅ の書式は、

	_procedure サブルーチン名 ( 引き数リスト ) : 定義側レジスタ保護情報

　となります。引き数リスト、レジスタ保護情報は省略可能です。
　引き数リストを省略する場合には、()
　保護情報を省略する場合には : を書いてはいけません。

　（１）サブルーチン名

　　LABEL: として展開されるサブルーチン名を指定します。
　　そのままラベルとして展開されるので、ラベルとして使用できないシンボルを
　　指定することは出来ません。

　（２）引き数リスト

　　ｐｒｏｃ文（後述）で指定される引き数を受け取るレジスタ、変数を書きます。
　　複数ある場合には、カンマ (,) で区切って書きます。

　　引き数を受け取る側なので、即値や定数を書くことは出来ません。
　　数値定数の場合には警告を発しますが、定数シンボルの場合にはＡＰＰは警告を
　　発しませんので注意が必要です。

　　通常、引き数の受け渡しは MOV 命令を使って、呼び出し側に展開されます。
　　したがって、引き数の受取側にレジスタを指定した場合には、定義側で変数を
　　保存したとしても、保存する前に内容が破壊される事態が起こり得ます。
　　これを防ぐためには、引き数が渡される前に受取側レジスタを保存することが
　　必要となります。
　　ところが、受け取りレジスタが何であるかを呼び出し側で管理するのは少々面倒
　　であるようにおもわれます。

　　そこで、　引き数リストのレジスタ名の先頭に (^,!) などのキャラクタを付け
　　加えることで、呼び出し側のレジスタ保護命令の生成を制御できるようになって
　　います。
.p


	制御キャラクタ			効果

		^	引き渡し命令の前に PUSH , CALL 文のあとに POP を
			自動的に生成します（呼び出し側で抑制することも可能）。
			バイトレジスタにたいしてこのキャラクタを付加した場合
			でも、　レジスタのセーブはワード単位で行われますので
			注意が必要です。

		!	引き渡し命令として、 MOV の変わりに XCHG を用います。
			また CALL 文の後にも XCHG が生成されますので、サブル
			ーチン中でのレジスタに対する操作が、呼び出し側レジス
			タにそのまま反映されます。
			このキャラクタを ^ と共に使用することは出来ません。
			当然ながら、このキャラクタが付加された引き数に対して
			定数引き数を与える事は出来なくなります。

		*	引き渡し命令として、LEA をもちいます。
			引き数として実効アドレスのみが許されます。
			呼び出し時に OFFSET キーワード （80x86 ニーモニック）
			を書く必要がなくなります。
			^ キャラクタと両方同時に使用することも可能ですが、
			必ず ^* の順で続けて書いてください。


	（例） _procedure TEST (AX,^BX,*DI,^*SI,!CX)

	　上記の定義をした場合に、
	　呼び出し側で、

	　　　_proc TEST (100,200,DATA,DATA2,BP)

	　と書いた場合、（呼び出し側では）以下のように展開されます

		MOV	AX,100		; １番目の引き数
		PUSH	BX		; ２番目の引き数
		MOV	BX,200
		LEA	DI,DATA		; ３番目の引き数
		PUSH	SI		; ４番目の引き数
		LEA	SI,DATA2
		XCHG	BP,CX		; ５番目の引き数
		CALL	TEST		; サブルーチンコール
		XCHG	BP,CX		;	|
		POP	SI		;（保存レジスタのリストア）
		POP	BX		;	|

　（３）定義側レジスタ保護情報

　　ここには、サブルーチンの先頭で保存すべきレジスタ、変数を書きます。
　　複数ある場合には、カンマ (,) で区切って書きます。
　　ただし、ここの記述はそのまま PUSH , POP 文に書いた順で展開されますので、
　　PUSH , POP のオペランドとなり得るレジスタ、変数以外を書くことは出来ません
　　（バイトレジスタ、即値、変数でないシンボルは不可）。

.p
　呼び出し側文 ｐｒｏｃ の書式は

	_proc サブルーチン名 ( 引き数リスト ) : 呼び出し側レジスタ保護情報 ;

　となります。引き数リスト、レジスタ保護情報は省略可能です。
　引き数リストを省略する場合には、()
　保護情報を省略する場合には : を書いてはいけません。

　（１）サブルーチン名

　　ｐｒｏｃｅｄｕｒｅ文で定義したサブルーチン名を指定します。

　（２）引き数リスト

　　ｐｒｏｃｅｄｕｒｅ文で指定された引き数を受け取るレジスタ、変数に対して
　　引き渡す値、および XCHG の場合には交換するレジスタ、変数名を書きます。
　　複数ある場合には、カンマ (,) で区切って書きます。

　　引き数の個数が定義側と呼び出し側で異なる場合にはエラーとなります。
　　ただし、引き数の型の不一致に関してＡＰＰはエラーを発しませんので、注意が
　　必要です。

　　呼び出し側に ^ , ! , * 等のキャラクタを書くことは出来ません。
　　~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


　（３）呼び出し側レジスタ保護情報

　　ここには、サブルーチンの呼び出し側で保存すべきレジスタ、変数を書きます。
　　複数ある場合には、カンマ (,) で区切って書きます。
　　ただし、実際に PUSH , POP 命令が生成されるのは、そのレジスタが定義側で
　　^ キャラクタを用いて宣言されている場合のみです。

　　何もかかれていない場合（省略時）には、^ で宣言されたすべてのレジスタが
　　~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
　　保存されます。
　　~~~~~~~~~~~~~~
　　レジスタ名が一つでも記述されている場合には、記述されているレジスタのみが
　　~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
　　保存されます（もちろん ^ 宣言されている必要が有る）。
　　~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
　　また、ここに NONE の記述が有った場合には、どのレジスタも保護されません。
　　~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

　　したがって、通常このフィールドは、何も書かないでおくのですが、
　　メインルーチンからの呼び出しなどで、明らかにレジスタを保護する必要がない
　　場合や、保護すべきレジスタが明らかに限定されている場合などに、不要な PUSH
　　 POP の生成を抑制するために使用します。

　　^ 宣言されていないレジスタを記述してもかまいませんので、定義側を気にせず、
　　呼び出し側で保存すべきレジスタをすべて記述しておくこともできます。
　　このようにすると、定義側では保護すべきレジスタには ^ が記述されるわけです
　　から、呼び出し側の要求と、定義側の宣言が一致したときのみレジスタの保護を
　　行うというような形になり、効率的なレジスタ保護が可能となります。

　　また、デバッグ時には記述しないでおいて（すべて保存）、調整時に必要なレジ
　　スタを絞りこむようにする（限定保存）、というような使い方も可能です。
.p

　※引き数の受渡しに伴って起こり得る問題

　　ＡＰＰのサブルーチン形式における引き数の受渡しは、すべてレジスタに頼る
　形を取っています。これは、通常のアセンブラプログラムを書く上で、引き数を
　スタックに積んで渡さねばならないことがまれであり、また、スタックに積んで
　引き数を渡す形式をサポートしたところで、それは高級言語コンパイラとなんら
　変わらないコードを生成するのみとなり（ただの変換なので更に効率が低下する
　かもしれない。　恐らくＣコンパイラの方が最適化されたコードを出力するで
　あろうと思える）、ＡＰＰの目的に添うものではなくなります。

　以上の理由から、レジスタに依って引き数を渡しています。

　ここで問題となるのは、 MOV 命令を用いて引き数を「順に」（「同時」で無い事
　                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
　に注意）渡す際に、受渡しレジスタが前後すると、渡す前の値が破壊されてしまう
　~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
　ということが起こり得ることです。
　~~~~~~~~~~~~~~~~~~~~~~

　例を出して説明します。

	_procedure ARGPROBLEM (AX,BX)	; 定義部分

　上記のようなサブルーチンに対して、次のような呼び出し部分が存在したとします。

	_proc ARGPROBLEM (BX,AX)

　上の呼び出し部分をＡＰＰの展開規則にしたがって展開すると

	MOV	AX,BX			; １番目
	MOV	BX,AX			; ２番目（既にＡＸは破壊されている）
	CALL	ARGPROBLEM

　となり、２番目の引き数を渡す前に既にＡＸが破壊されてしまいます。

　ＡＰＰでこれを自動訂正する機能は備わっていませんが、このような展開結果に
　なる可能性が有る場合　−　既に引き数として値を渡されている（破壊された）
　レジスタからの代入が発生する場合には、警告メッセージを発生するようになって
　います。

　使い方によっては頻繁に発生する可能性も有りますので、十分注意してください。
　なお、上記のような場合には、

	XCHG	AX,BX
	_proc	ARGPROBLEM (AX,BX)
	XCHG	AX,BX

　とすれば回避できます。


　なお、ＡＰＰでは

	MOV	AX,AX

　のように引き数の呼び出し側と受取側が一致している場合には、MOV , XCHG 
　は生成されません。
.p

 《ｐｒｏｃｅｄｕｒｅ形式を通常のＣＡＬＬ（８０ｘ８６）で使う場合》

　　プログラムの全体ではなく、一部分のみをＡＰＰで書いた場合や、今まで通常の
　サブルーチンであったものをＡＰＰ形式に書き換えた場合などに、こういう変則的
　利用をしたい場合が有ります。

　ｐｒｏｃｅｄｕｒｅ形式の定義部分で展開されるコードは、ラベルと、レジスタ
　保護のための PUSH , POP のみです。
　定義側における受け側レジスタの指定は呼び出し側において展開されるもので、
　定義部分においては展開されません。

　したがって、呼び出し側（ｐｒｏｃ文）の展開結果と同じ様に引き数（つまりは
　使用される値）さえ渡してやれば、通常のＣＡＬＬ文から使用が可能です。
.p


　ｂ．ｆｕｎｃｔｉｏｎ形式

　　ｆｕｎｃｔｉｏｎ形式はＡＰＰ独特のサブルーチン形式であり、かなり制限は
　あるものの、高級言語の関数形式と同様に、戻り値をもち、リエントラントな関数
　を実現できます。

　ｆｕｎｃｔｉｏｎ形式はｐｒｏｃｅｄｕｒｅ形式と非常によく似ていますが、以下の
　点で異なります。

　　・特定のレジスタ（ＢＰ）を利用して、呼び出し側に値を返す。

　　・戻り値を受け取る変数とともに呼び出し部分を記述する。

　　・条件式中にも記述可能である。

　　・特定のレジスタに依存（BP レジスタ）し、そのレジスタ（BP）を破壊する。

　　・ｆｕｎｃ、ｐｒｏｃの引き数にｆｕｎｃを記述可能（Release 1.39 以降）。


　定義文 ｆｕｎｃｔｉｏｎ の書式は、

	_function サブルーチン名 ( 引き数リスト ) : 定義側レジスタ保護情報

　となります。引き数リスト、レジスタ保護情報は省略可能です。
　引き数リストを省略する場合には、()
　保護情報を省略する場合には : を書いてはいけません。

　また ｆｕｎｃｔｉｏｎ の終わりは

	_endf

　で示します。ただし、ｅｎｄｐ とは違い、ｅｎｄｆは RET 命令を生成しません。
					 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
　これは、ｆｕｎｃｔｉｏｎ には必ず戻り値が必要であり、そのために

	_return （戻り値）

　という書式で示される ｒｅｔｕｒｎ 文があり、この命令によって RET を生成する
　ようになっているためです。

　（１）サブルーチン名

　　LABEL: として展開されるサブルーチン名を指定します。
　　そのままラベルとして展開されるので、ラベルとして使用できないシンボルを
　　指定することは出来ません。

　（２）引き数リスト

　　ｐｒｏｃｅｄｕｒｅ形式とまったく同じですので、そちらを参照してください。
　　例と、展開結果のみ以下に示します。

	　　　_function TEST (AX,^BX,*DI,^DI)

	　上記の定義をした場合に、
	　呼び出し側で、

	　　　AX = _func TEST (100,200,DATA,DATA2)

	　と書いた場合、（呼び出し側では）以下のように展開されます。
	　（* のついた行がｐｒｏｃｅｄｕｒｅと異なる）

		MOV	AX,100		; １番目の引き数
		PUSH	BX		; ２番目の引き数
		MOV	BX,200
		LEA	DI,DATA		; ３番目の引き数
		PUSH	SI		; ４番目の引き数
		LEA	SI,DATA2
		CALL	TEST		; サブルーチンコール
	      * MOV	AX,BP		; 戻り値のうけとり
		POP	SI		;（保存レジスタのリストア）
		POP	BX		;	|

　（３）定義側レジスタ保護情報

　　ｐｒｏｃｅｄｕｒｅ形式と同様です。


　呼び出し側文 ｆｕｎｃ の書式は

　受け取り変数名 = _func サブルーチン名 ( 引き数リスト ) : レジスタ保護情報 ;

　となります。引き数リスト、レジスタ保護情報は省略可能です。
　引き数リストを省略する場合には、()
　保護情報を省略する場合には : を書いてはいけません。

　（１）受け取り変数名

　　ｒｅｔｕｒｎ文によってサブルーチンから返される値を受け取る変数、レジスタ
　　名を書きます。 BP レジスタから受け取りますので、ワード型以外を記述する
　　ことはできません。

　（２）サブルーチン名

　　ｆｕｎｃｔｉｏｎ文で定義したサブルーチン名を指定します。

　（３）引き数リスト

　　ｐｒｏｃ文の説明を参照してください。

　（４）レジスタ保護情報

　　ｐｒｏｃ文の説明を参照してください。


　ｒｅｔｕｒｎ文の書式は

	_return	 （戻り値）

　です。戻り値は即値、もしくはワード型の変数を記述できます。
　ｒｅｔｕｒｎ 文は ｆｕｎｃｔｉｏｎーｅｎｄｆ 間に少なくとも１つ存在しなけ
　ればなりません。また、ｐｒｏｃｅｄｕｒｅ 文中に記述することもできますが、
　この場合戻り値を記述することは出来ません。
.p


　《ｆｕｎｃ、ｐｒｏｃ の引き数として ｆｕｎｃ を使用する際の注意》

　　Release 1.39 以降のバージョンでは、ｐｒｏｃ，ｆｕｎｃ の引き数に ｆｕｎｃ
　を記述できるようになり、ｆｕｎｃｔｉｏｎ 形式の用途が広がりました。

　（例）
	_function f(ax)
		add	ax,10
		_return	ax
	_endf

	ax = _func f (_func f (_func f (10)))


　（呼び出し部分の展開後のコード）

	;	ax = _func f (_func f (_func f (10)))
        MOV     AX,10
        CALL    f
        MOV     AX,BP
        CALL    f
        MOV     AX,BP
        CALL    f
        MOV     AX,BP

　このように、ｆｕｎｃ の引き数（ｗｏｒｄ型のみ）に ｆｕｎｃ を記述できます。

　しかし、引き数を二つ以上持つ ｆｕｎｃ 呼び出しの引き数として ｆｕｎｃ を記述
　する際には、レジスタの保護に気を付ける必要が有ります。

　（よくない例）

	_function add(ax,bx)
		add	ax,bx
		_return ax
	_endf

	_function add10(ax)	; ax レジスタを保護しようとしていない
		add	ax,10
		_return	ax
	_endf

	x = _func add(10 , _func add10(2))


　（呼び出し部分の展開結果）

        ;        x = _func add(10 , _func add10(2))
        MOV     AX,10		; add の第１引き数

        MOV     AX,2		; _func add10(2) の値を計算するため
        CALL    add10		; add10 を呼びだそうとするが、その際に
                		; add の第１引き数の代入結果が破壊される。
				; ( MOV	AX,2 )

	MOV	BX,BP		; add の第２引き数

        CALL    add
        MOV     X,BP


　上記のように、引き数の受渡しに使用しているレジスタが破壊される場合が有り、
　注意を要しますが、レジスタ保護情報を適切に記述することで回避できます。


　（正しく動作する例）

	_function add(ax,bx)
		add	ax,bx
		_return ax
	_endf

	_function add10(^ax)	; ax レジスタを保護している (^)
		add	ax,10
		_return	ax
	_endf

	x = _func add(10 , _func add10(2))


　（呼び出し部分の展開結果）

        ;        x = _func add(10 , _func add10(2))
        MOV     AX,10

        PUSH    AX		; ＡＸは保護され、意図通りに動作する。
        MOV     AX,2
        CALL    add10
        POP     AX

        MOV     BX,BP
        CALL    add
        MOV     X,BP
.p


　《ｆｕｎｃｔｉｏｎの条件式中での使用》

　　条件式中に記述する場合には、次の形式のみが許されます。

    （ｆｕｎｃ呼び出し）（条件）（ワード変数／定数／即値）

　　（例）
　　　　　_if _func GETCHAR == 'A'

　　_func は必ず式の左辺になければなりません。

　　展開コードは以下の通りです。

        ;　　　　　_if _func GETCHAR == 'A'
        CALL    GETCHAR
        CMP     BP,'A'
        JNE     $ELSE_1


　　また、複数の条件をならべて書く場合には、その関数が必ずしも呼ばれるとは
　　限りません。

　　（例）
	　_if _func GETCHAR == '@' || BUFPTR < OFFSET BUFEND

　　このとき、後の条件が成立してしまえば、_function GETCHAR はよばれない。

　　展開コードは以下の通りです。

        ;        　_if _func GETCHAR == '@' || BUFPTR < OFFSET BUFEND
        CMP     BUFPTR,OFFSET BUFEND
        JB      $TMP_0
        CALL    GETCHAR
        CMP     BP,'@'
        JNE     $ELSE_1
$TMP_0:
.p


　《条件式における型指定／擬似キャスト (Release 1.33p)》

　　条件式内で型の決まってない変数に対して、型を指定できるようになりました。
　　書式は (型名)変数名　です。

　　型名としてサポートされているのは　BYTE , WORD の２種類のみです。

　　条件式以外ではｆｏｒ文のいずれのパラメータにも使用できます。
　　ただし、インクリメント／デクリメント指定は型名の前に記述します。

　（例）
	_if (byte)[BX] == 0

	_for (byte)[BX]=0,(byte)[BX] < 10,++(byte)[BX]
			.
			.
	_next

　　展開後のコードは以下の通りです。

        ;        _if (byte)[BX] == 0
        CMP     BYTE PTR [BX],0
        JNE     $ELSE_1


        ;        _for (byte)[BX]=0,(byte)[BX] < 10,++(byte)[BX]
        MOV     BYTE PTR [BX],0
        JMP     $FORBG_1
$BEGIN_1:
		.
		.
        ;       _next
        INC     BYTE PTR [BX]
$FORBG_1:
        CMP     BYTE PTR [BX],10
        JB      $BEGIN_1
.p


＜その他のＡＰＰ制御命令＞

◆ ｉｎｃｌｕｄｅ　（ファイル名）

　ファイルをインクルードします。

　（例）
	_include TEST.INC


◆ ｎｅａｒ
◆ ｓｈｏｒｔ

　生成する条件ジャンプ命令のタイプを指定します。

　（例）
	_short	（この命令以降、条件ジャンプは short 命令が生成されます）
	_near　 （この命令以降、条件ジャンプは near ジャンプに変更されます）

.p
§現在の所試験的に導入されている命令
　（将来的にサポートが継続されるかどうかは未決定）

◆ ｐｕｂｌｉｃ

　今までに実態が定義されたｆｕｎｃｔｉｏｎ、ｐｒｏｃｅｄｕｒｅの
　ｐｕｂｌｉｃ宣言を出力します。


◆ ｃｏｎｓｔｏｕｔ

　文字列定数の宣言スタックの内容をこの命令のある部分で掃き出します。

　ｖｅｒ１．４０では文字列定数が一部サポートされています。
　プログラム中で文字列定数を用いると、適当なシンボルで置換され、
　文字列スタックにシンボルと実体が保存されます。

　保存された文字列と定義はその定義以降まとめて出力させますが、
　ｃｏｎｓｔｏｕｔ命令はその出力箇所を指定する物です。

　（例）プログラム例

	.CODE
	_procedure MAIN
		_proc PRINT("試験的に導入された文字列定数型")
		_proc PRINT("ＡＳＣＩＩＺをサポートします")
	_endp

	.DATA
	_constout　＜＝ここで出力


　　　変換後

        .CODE
	;        _procedure MAIN
MAIN:
	;                _proc PRINT("試験的に導入された文字列定数型")
	MOV	BX,OFFSET CTS_1
	CALL	PRINT
	;                _proc PRINT("ＡＳＣＩＩＺをサポートします")
	MOV	BX,OFFSET CTS_2
	CALL	PRINT
	;        _endp
	RET

        .DATA
	;        _constout
CTS_1	DB	"試験的に導入された文字列定数型",0
CTS_2	DB	"ＡＳＣＩＩＺをサポートします",0
.p



